ntng.results[, 1] <- factor(ntng.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntng.results[, 2] <- factor(ntng.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntng.results$transcript_id <- rownames(ntng.results)
# Make dataset that has the absent transcripts from the ALO data removed
full.transcript.set <- as.data.frame(rbind(known.results, ntkg.results, ntng.results))
'%!in%' <- function(x,y)!('%in%'(x,y))
transcript.set.hires <- full.transcript.set[which(full.transcript.set$RS.atleast1 %!in% c("Not present")), ]
transcript.set.hires$transcript_id <- rownames(transcript.set.hires)
subtype <- c("Present in both", "Present in ALO IB", "Present in ALO RI")
subtype2 <- c("Present in all strains", "Present in all IB", "Present all RI")
dataList <- list(known.results, ntkg.results, ntng.results)
refDat <- transcript.set.hires
i = 1
i2 = 2
qcDF <- contentQC(subtype, dataList, refDat, i)
return(list(qcDF, qcDF[4,2], qcDF[4,3], qcDF[4,4]))
}
## This function is runs the sample.and.summarize functions over and over essentitally acting as a resampling method. It then extracts the totals generated by the sample.and.summarize function, vectorizes them, and then summarizes them into means, stds, and sems. It then binds these into one final dataset for output. NOTE: the dimensions of the matrix for each summary measure should be 3xthe number of resamplings.
sample.means.sds <- function(j, i){
library(plotrix)
rep <- replicate(5, sample.and.summarize(PA.table.RMO, RI.num = j, IB.num = i))
means <- apply(matrix(as.numeric(rep[-1, ]), 3, 5), 1, FUN = function(x) mean(x))
sds <- apply(matrix(as.numeric(rep[-1, ]), 3, 5), 1, FUN = function(x) sd(x))
sem <- apply(matrix(as.numeric(rep[-1, ]), 3, 5), 1, FUN = function(x) std.error(x))
df.out <- rbind(c("IB", "RI", "HRDP"), means, sds, sem)
}
## Specify the number of strains to sample for each iteration where j is for RI and i is for classic IBs
j <- c(2, 5, 10, 15, 20, 25, 30, 32)
i <- c(2, 5, 10, 11, 11, 11, 11, 11)
## Using mapply here allows feeding the sample.means.sds function 2 separate strain sample number vectors.
avgsem <- mapply(sample.means.sds, j, i)
avgsem
## reformat avgsem into a ggplot friednly format
panels <- c(avgsem[c(1,5,9), ])
avgs <- c(avgsem[c(2,6,10), ])
sdevs <- c(avgsem[c(3,7,11), ])
sems <- c(avgsem[c(4,8,12), ])
avgsem.forPlot <- as.data.frame(cbind(panels, avgs, sdevs, sems))
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
avgsem.forPlot
numsampled <- c(rep(j, 3))
## reformat avgsem into a ggplot friednly format
panels <- c(avgsem[c(1,5,9), ])
avgs <- c(avgsem[c(2,6,10), ])
sdevs <- c(avgsem[c(3,7,11), ])
sems <- c(avgsem[c(4,8,12), ])
numsampled <- c(rep(j, 3))
avgsem.forPlot <- as.data.frame(cbind(panels, avgs, sdevs, sems))
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
avgsem.forPlot
panels <- c(avgsem[c(1,5,9), ])
avgs <- c(avgsem[c(2,6,10), ])
sdevs <- c(avgsem[c(3,7,11), ])
sems <- c(avgsem[c(4,8,12), ])
numsampled <- c(rep(j, 3))
avgsem.forPlot <- as.data.frame(cbind(panels, numsampled, avgs, sdevs, sems))
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
avgsem.forPlot
avgs
avgsem
sample.means.sds <- function(j, i){
library(plotrix)
rep <- replicate(5, sample.and.summarize(PA.table.RMO, RI.num = j, IB.num = i))
means <- apply(matrix(as.numeric(rep[-1, ]), 3, 5), 1, FUN = function(x) mean(x))
sds <- apply(matrix(as.numeric(rep[-1, ]), 3, 5), 1, FUN = function(x) sd(x))
sem <- apply(matrix(as.numeric(rep[-1, ]), 3, 5), 1, FUN = function(x) std.error(x))
df.out <- rbind(c("IB", "RI", "HRDP"), means, sds, sem, j)
}
## Specify the number of strains to sample for each iteration where j is for RI and i is for classic IBs
j <- c(2, 5, 10, 15, 20, 25, 30, 32)
i <- c(2, 5, 10, 11, 11, 11, 11, 11)
## Using mapply here allows feeding the sample.means.sds function 2 separate strain sample number vectors.
avgsem <- mapply(sample.means.sds, j, i)
## reformat avgsem into a ggplot friednly format
panels <- c(avgsem[c(1,5,9), ])
avgs <- c(avgsem[c(2,6,10), ])
sdevs <- c(avgsem[c(3,7,11), ])
sems <- c(avgsem[c(4,8,12), ])
strainsampled <- c(avgsem[c(5, 9, 13), ])
avgsem.forPlot <- as.data.frame(cbind(panels, strainsampled, avgs, sdevs, sems))
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
avgsem.forPlot
avgsem
strainsampled
## reformat avgsem into a ggplot friednly format
panels <- c(avgsem[c(1,6,11), ])
avgs <- c(avgsem[c(2,7,12), ])
sdevs <- c(avgsem[c(3,8,13), ])
sems <- c(avgsem[c(4,9,14), ])
strainsampled <- c(avgsem[c(5, 10, 15), ])
avgsem.forPlot <- as.data.frame(cbind(panels, strainsampled, avgs, sdevs, sems))
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
avgsem.forPlot
pdf(file = "/Users/smiharry/Desktop/Saba_Lab/Liver/Graphics/strainNumberEffect.pdf")
ggplot(avgsem.forPlot, aes(x=strainsampled, y=avgs, colour=panels)) +
geom_errorbar(aes(ymin=avgs-sems, ymax=avgs+sems), width=.1) +
geom_line() +
geom_point()
dev.off()
library(ggplot2)
library(RColorBrewer)
pdf(file = "/Users/smiharry/Desktop/Saba_Lab/Liver/Graphics/strainNumberEffect.pdf")
ggplot(avgsem.forPlot, aes(x=strainsampled, y=avgs, colour=panels)) +
geom_errorbar(aes(ymin=avgs-sems, ymax=avgs+sems), width=.1) +
geom_line() +
geom_point()
dev.off()
avgsem.forPlot
apply(avgsem.forPlot, 2, function(x) typeof(x))
pdf(file = "/Users/smiharry/Desktop/Saba_Lab/Liver/Graphics/strainNumberEffect.pdf")
ggplot(avgsem.forPlot, aes(x=as.numeric(strainsampled), y=as.numeric(avgs), colour=as.factor(panels))) +
geom_errorbar(aes(ymin=avgs-sems, ymax=avgs+sems), width=.1) +
geom_line() +
geom_point()
dev.off()
as.numeric(strainsampled)
panels <- c(as.factor(avgsem[c(1,6,11), ]))
avgs <- c(as.numeric(avgsem[c(2,7,12), ]))
sdevs <- c(as.numeric(avgsem[c(3,8,13), ]))
sems <- c(as.numeric(avgsem[c(4,9,14), ]))
strainsampled <- c(as.numeric(avgsem[c(5, 10, 15), ]))
avgsem.forPlot <- as.data.frame(cbind(panels, strainsampled, avgs, sdevs, sems))
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
apply(avgsem.forPlot, 2, function(x) typeof(x))
panels
?factor
panels <- c(factor(avgsem[c(1,6,11), ], levels = c(2,3,1), labels = c("IB", "RI", "HRDP")))
avgs <- c(as.numeric(avgsem[c(2,7,12), ]))
sdevs <- c(as.numeric(avgsem[c(3,8,13), ]))
sems <- c(as.numeric(avgsem[c(4,9,14), ]))
strainsampled <- c(as.numeric(avgsem[c(5, 10, 15), ]))
avgsem.forPlot <- as.data.frame(cbind(panels, strainsampled, avgs, sdevs, sems))
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
avgsem.forPlot
panels
## reformat avgsem into a ggplot friednly format
panels <- c(factor(avgsem[c(1,6,11), ], levels = c("IB","RI","HRDP"), labels = c("IB", "RI", "HRDP")))
avgs <- c(as.numeric(avgsem[c(2,7,12), ]))
sdevs <- c(as.numeric(avgsem[c(3,8,13), ]))
sems <- c(as.numeric(avgsem[c(4,9,14), ]))
strainsampled <- c(as.numeric(avgsem[c(5, 10, 15), ]))
panels
panels <- c(avgsem[c(1,6,11), ])
avgs <- c(as.numeric(avgsem[c(2,7,12), ]))
sdevs <- c(as.numeric(avgsem[c(3,8,13), ]))
sems <- c(as.numeric(avgsem[c(4,9,14), ]))
strainsampled <- c(as.numeric(avgsem[c(5, 10, 15), ]))
panels
panels <- c(avgsem[c(1,6,11), ])
avgs <- c(as.numeric(avgsem[c(2,7,12), ]))
sdevs <- c(as.numeric(avgsem[c(3,8,13), ]))
sems <- c(as.numeric(avgsem[c(4,9,14), ]))
strainsampled <- c(as.numeric(avgsem[c(5, 10, 15), ]))
avgsem.forPlot <- as.data.frame(cbind(panels, strainsampled, avgs, sdevs, sems))
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
avgsem.forPlot
apply(avgsem.forPlot, 2, functio(x) typeof(x))
apply(avgsem.forPlot, 2, function(x) typeof(x))
panels <- c(avgsem[c(1,6,11), ])
avgs <- c(as.numeric(avgsem[c(2,7,12), ]))
sdevs <- c(as.numeric(avgsem[c(3,8,13), ]))
sems <- c(as.numeric(avgsem[c(4,9,14), ]))
strainsampled <- c(as.numeric(avgsem[c(5, 10, 15), ]))
avgsem.forPlot <- as.data.frame(cbind(panels, strainsampled, avgs, sdevs, sems))
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
avgsem.forPlot
apply(avgsem.forPlot, 2, function(x) typeof(x))
avgsem.forPlot <- data.frame(Panel=panels, SSampled=strainsampled, Mean=avgs, SD=sdevs, SEM=sems)
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$panels), ]
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$Panel), ]
avgsem.forPlot
apply(avgsem.forPlot, 2, function(x) typeof(x))
pdf(file = "/Users/smiharry/Desktop/Saba_Lab/Liver/Graphics/strainNumberEffect.pdf")
ggplot(avgsem.forPlot, aes(x=strainsampled, y=avgs, colour=panels)) +
geom_errorbar(aes(ymin=avgs-sems, ymax=avgs+sems), width=.1) +
geom_line() +
geom_point()
dev.off()
## WORKING FROM LOCAL MACHINE SOURCE ##
source("~/Desktop/Saba_Lab/Liver/code/rsem.read.R")
## Create global directory objects
dir <- "/Volumes/smiharry/Saba_Lab/RNA-Seq/HRDP/"
dirs2 <- "/Volumes/rn6/quantitation/liverTotalRNA/RI/"
dirlocal <- "~/Desktop/Saba_Lab/"
N <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
tissue <- "Liver"
library(reshape2)
library(ggplot2)
library(RColorBrewer)
## WORKING FROM LOCAL MACHINE LOAD ##
load(file = paste(dirlocal, tissue, "/quantitation/",  "PA.table.RMO", ".Rdata", sep = ""))
## create sample.and.summarize function which breaks present/absent table up into classic IB dataset and RI dataset. Then randomly samples these datasets starting with low levels, then increasing the number of strains sampled until it gets to the complete number of strains in each dataset. It then summarizes this these data in the same way the original sep.panel function does. It returns a list of values extracted from a content summary table as it is created by the contentQC function (i.e. it is pulling out the by panel totals).
sample.and.summarize <- function(PA.table.RMO, ...) {
library(plyr)
## summarize transcript content using sep.panel function. This function will create useful datasets as well.
content.summary <- sep.panel.sample(PA.table.RMO, ...)
# Subset columns with present/absent codes
known.results <- content.summary$KN_Results[, c(5,6)]
ntkg.results <- content.summary$NTKG_Results[, c(5,6)]
ntng.results <- content.summary$NTNG_Results[, c(5,6)]
# Change codes to factor and give meaningful labels for both known and novel datasets
known.results[, 1] <- factor(known.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
known.results[, 2] <- factor(known.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
known.results$transcript_id <- rownames(known.results)
ntkg.results[, 1] <- factor(ntkg.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntkg.results[, 2] <- factor(ntkg.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntkg.results$transcript_id <- rownames(ntkg.results)
ntng.results[, 1] <- factor(ntng.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntng.results[, 2] <- factor(ntng.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntng.results$transcript_id <- rownames(ntng.results)
# Make dataset that has the absent transcripts from the ALO data removed
full.transcript.set <- as.data.frame(rbind(known.results, ntkg.results, ntng.results))
'%!in%' <- function(x,y)!('%in%'(x,y))
transcript.set.hires <- full.transcript.set[which(full.transcript.set$RS.atleast1 %!in% c("Not present")), ]
transcript.set.hires$transcript_id <- rownames(transcript.set.hires)
subtype <- c("Present in both", "Present in ALO IB", "Present in ALO RI")
subtype2 <- c("Present in all strains", "Present in all IB", "Present all RI")
dataList <- list(known.results, ntkg.results, ntng.results)
refDat <- transcript.set.hires
i = 1
i2 = 2
qcDF <- contentQC(subtype, dataList, refDat, i)
return(list(qcDF, qcDF[4,2], qcDF[4,3], qcDF[4,4]))
}
## This function is runs the sample.and.summarize functions over and over essentitally acting as a resampling method. It then extracts the totals generated by the sample.and.summarize function, vectorizes them, and then summarizes them into means, stds, and sems. It then binds these into one final dataset for output. NOTE: the dimensions of the matrix for each summary measure should be 3xthe number of resamplings.
sample.means.sds <- function(j, i){
library(plotrix)
rep <- replicate(5, sample.and.summarize(PA.table.RMO, RI.num = j, IB.num = i))
means <- apply(matrix(as.numeric(rep[-1, ]), 3, 5), 1, FUN = function(x) mean(x))
sds <- apply(matrix(as.numeric(rep[-1, ]), 3, 5), 1, FUN = function(x) sd(x))
sem <- apply(matrix(as.numeric(rep[-1, ]), 3, 5), 1, FUN = function(x) std.error(x))
df.out <- rbind(c("IB", "RI", "HRDP"), means, sds, sem, j)
}
## Specify the number of strains to sample for each iteration where j is for RI and i is for classic IBs
j <- c(2, 5, 10, 15, 20, 25, 30, 32)
i <- c(2, 5, 10, 11, 11, 11, 11, 11)
## Using mapply here allows feeding the sample.means.sds function 2 separate strain sample number vectors.
avgsem <- mapply(sample.means.sds, j, i)
## reformat avgsem into a ggplot friednly format
panels <- c(avgsem[c(1,6,11), ])
avgs <- c(as.numeric(avgsem[c(2,7,12), ]))
sdevs <- c(as.numeric(avgsem[c(3,8,13), ]))
sems <- c(as.numeric(avgsem[c(4,9,14), ]))
strainsampled <- c(as.numeric(avgsem[c(5, 10, 15), ]))
avgsem.forPlot <- data.frame(Panel=panels, SSampled=strainsampled, Mean=avgs, SD=sdevs, SEM=sems)
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$Panel), ]
pdf(file = "/Users/smiharry/Desktop/Saba_Lab/Liver/Graphics/strainNumberEffect.pdf")
ggplot(avgsem.forPlot, aes(x=strainsampled, y=avgs, colour=panels)) +
geom_errorbar(aes(ymin=avgs-sems, ymax=avgs+sems), width=.1) +
geom_line() +
geom_point()
dev.off()
avgsem.forPlot
## Source rsem.read
source("/Volumes/smiharry/Saba_Lab/RNA-Seq/HRDP/Transcript_Reconstruction/code/rsem.read.R")
## WORKING FROM LOCAL MACHINE SOURCE ##
source("~/Desktop/Saba_Lab/Liver/code/rsem.read.R")
## Create global directory objects
dir <- "/Volumes/smiharry/Saba_Lab/RNA-Seq/HRDP/"
dirs2 <- "/Volumes/rn6/quantitation/liverTotalRNA/RI/"
dirlocal <- "~/Desktop/Saba_Lab/"
N <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
tissue <- "Liver"
library(reshape2)
library(ggplot2)
library(RColorBrewer)
## WORKING FROM LOCAL MACHINE LOAD ##
load(file = paste(dirlocal, tissue, "/quantitation/",  "PA.table.RMO", ".Rdata", sep = ""))
## create sample.and.summarize function which breaks present/absent table up into classic IB dataset and RI dataset. Then randomly samples these datasets starting with low levels, then increasing the number of strains sampled until it gets to the complete number of strains in each dataset. It then summarizes this these data in the same way the original sep.panel function does. It returns a list of values extracted from a content summary table as it is created by the contentQC function (i.e. it is pulling out the by panel totals).
sample.and.summarize <- function(PA.table.RMO, ...) {
library(plyr)
## summarize transcript content using sep.panel function. This function will create useful datasets as well.
content.summary <- sep.panel.sample(PA.table.RMO, ...)
# Subset columns with present/absent codes
known.results <- content.summary$KN_Results[, c(5,6)]
ntkg.results <- content.summary$NTKG_Results[, c(5,6)]
ntng.results <- content.summary$NTNG_Results[, c(5,6)]
# Change codes to factor and give meaningful labels for both known and novel datasets
known.results[, 1] <- factor(known.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
known.results[, 2] <- factor(known.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
known.results$transcript_id <- rownames(known.results)
ntkg.results[, 1] <- factor(ntkg.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntkg.results[, 2] <- factor(ntkg.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntkg.results$transcript_id <- rownames(ntkg.results)
ntng.results[, 1] <- factor(ntng.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntng.results[, 2] <- factor(ntng.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntng.results$transcript_id <- rownames(ntng.results)
# Make dataset that has the absent transcripts from the ALO data removed
full.transcript.set <- as.data.frame(rbind(known.results, ntkg.results, ntng.results))
'%!in%' <- function(x,y)!('%in%'(x,y))
transcript.set.hires <- full.transcript.set[which(full.transcript.set$RS.atleast1 %!in% c("Not present")), ]
transcript.set.hires$transcript_id <- rownames(transcript.set.hires)
subtype <- c("Present in both", "Present in ALO IB", "Present in ALO RI")
subtype2 <- c("Present in all strains", "Present in all IB", "Present all RI")
dataList <- list(known.results, ntkg.results, ntng.results)
refDat <- transcript.set.hires
i = 1
i2 = 2
qcDF <- contentQC(subtype, dataList, refDat, i)
return(list(qcDF, qcDF[4,2], qcDF[4,3], qcDF[4,4]))
}
## This function is runs the sample.and.summarize functions over and over essentitally acting as a resampling method. It then extracts the totals generated by the sample.and.summarize function, vectorizes them, and then summarizes them into means, stds, and sems. It then binds these into one final dataset for output. NOTE: the dimensions of the matrix for each summary measure should be 3xthe number of resamplings.
sample.means.sds <- function(j, i){
library(plotrix)
rep <- replicate(100, sample.and.summarize(PA.table.RMO, RI.num = j, IB.num = i))
means <- apply(matrix(as.numeric(rep[-1, ]), 3, 100), 1, FUN = function(x) mean(x))
sds <- apply(matrix(as.numeric(rep[-1, ]), 3, 100), 1, FUN = function(x) sd(x))
sem <- apply(matrix(as.numeric(rep[-1, ]), 3, 100), 1, FUN = function(x) std.error(x))
df.out <- rbind(c("IB", "RI", "HRDP"), means, sds, sem, j)
}
## Specify the number of strains to sample for each iteration where j is for RI and i is for classic IBs
j <- c(2, 5, 10, 15, 20, 25, 30, 32)
i <- c(2, 5, 10, 11, 11, 11, 11, 11)
## Using mapply here allows feeding the sample.means.sds function 2 separate strain sample number vectors.
avgsem <- mapply(sample.means.sds, j, i)
## reformat avgsem into a ggplot friednly format
panels <- c(avgsem[c(1,6,11), ])
avgs <- c(as.numeric(avgsem[c(2,7,12), ]))
sdevs <- c(as.numeric(avgsem[c(3,8,13), ]))
sems <- c(as.numeric(avgsem[c(4,9,14), ]))
strainsampled <- c(as.numeric(avgsem[c(5, 10, 15), ]))
avgsem.forPlot <- data.frame(Panel=panels, SSampled=strainsampled, Mean=avgs, SD=sdevs, SEM=sems)
avgsem.forPlot <- avgsem.forPlot[order(avgsem.forPlot$Panel), ]
pdf(file = "/Users/smiharry/Desktop/Saba_Lab/Liver/Graphics/strainNumberEffect.pdf")
ggplot(avgsem.forPlot, aes(x=strainsampled, y=avgs, colour=panels)) +
geom_errorbar(aes(ymin=avgs-sems, ymax=avgs+sems), width=.1) +
geom_line() +
geom_point()
dev.off()
avgsem
harry <- sample.and.summarize(PA.table.RMO, RI.num = 5, IB.num = 5)
harry
content.summary <- sep.panel(PA.table.RMO)
# Subset columns with present/absent codes
known.results <- content.summary$KN_Results[, c(5,6)]
ntkg.results <- content.summary$NTKG_Results[, c(5,6)]
ntng.results <- content.summary$NTNG_Results[, c(5,6)]
# Change codes to factor and give meaningful labels for both known and novel datasets
known.results[, 1] <- factor(known.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
known.results[, 2] <- factor(known.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
known.results$transcript_id <- rownames(known.results)
ntkg.results[, 1] <- factor(ntkg.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntkg.results[, 2] <- factor(ntkg.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntkg.results$transcript_id <- rownames(ntkg.results)
ntng.results[, 1] <- factor(ntng.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntng.results[, 2] <- factor(ntng.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntng.results$transcript_id <- rownames(ntng.results)
# Make dataset that has the absent transcripts from the ALO data removed
full.transcript.set <- as.data.frame(rbind(known.results, ntkg.results, ntng.results))
'%!in%' <- function(x,y)!('%in%'(x,y))
transcript.set.hires <- full.transcript.set[which(full.transcript.set$RS.atleast1 %!in% c("Not present")), ]
transcript.set.hires$transcript_id <- rownames(transcript.set.hires)
subtype <- c("Present in both", "Present in ALO IB", "Present in ALO RI")
subtype2 <- c("Present in all strains", "Present in all IB", "Present all RI")
dataList <- list(known.results, ntkg.results, ntng.results)
refDat <- transcript.set.hires
i = 1
i2 = 2
contentQC <- function(subtype, dataList, refDat, i) {
st1 <- subtype[1]
st2 <- subtype[2]
st3 <- subtype[3]
qclist <- do.call("rbind", llply(dataList, .fun = function(x) {
known.pib <- x[which(x[,i] %in% c(st1)), ]
pib.test <- sum(known.pib[,3] %in% refDat$transcript_id) == length(known.pib[,3])
pib.len <- length(known.pib[,3])
known.IB <- x[which(x[,i] %in% c(st2)), ]
IB.test <- sum(known.IB[,3] %in% refDat$transcript_id) == length(known.IB[,3])
IB.len <- length(known.IB[,3])
known.RI <- x[which(x[,i] %in% c(st3)), ]
RI.test <- sum(known.RI[,3] %in% refDat$transcript_id) == length(known.RI[,3])
RI.len <- length(known.RI[,3])
known.test <- sum(pib.test, IB.test, RI.test) == 3
df <- c(pib.len, IB.len, RI.len, sum(pib.len, IB.len, RI.len), known.test)
}))
tots <- apply(qclist, 2, function(x) sum(x))
df.out <- rbind(qclist, tots)
df.out[,5] <- ifelse(df.out[,5] == c(1), "Yes", NA)
rownames(df.out) <- c("Known transcript of known gene", "Novel transcript of known gene", "Novel transcript of novel gene", "Totals")
colnames(df.out) <- c("Present in both", "Present in classic inbreds", "Present in recombinant inbreds", "Totals", "Subset of full dataset")
#names(qclist) <- c("KTKG", "NTKG", "NTNG")
return(df.out)
}
contentQC(subtype, dataList, refDat, i)
contentQC(subtype2, dataList, refDat, i2)
## summarize transcript content using sep.panel function. This function will create useful datasets as well.
content.summary <- sep.panel2(PA.table.RMO)
# Subset columns with present/absent codes
known.results <- content.summary$KN_Results[, c(5,6)]
ntkg.results <- content.summary$NTKG_Results[, c(5,6)]
ntng.results <- content.summary$NTNG_Results[, c(5,6)]
# Change codes to factor and give meaningful labels for both known and novel datasets
known.results[, 1] <- factor(known.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
known.results[, 2] <- factor(known.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
known.results$transcript_id <- rownames(known.results)
ntkg.results[, 1] <- factor(ntkg.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntkg.results[, 2] <- factor(ntkg.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntkg.results$transcript_id <- rownames(ntkg.results)
ntng.results[, 1] <- factor(ntng.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntng.results[, 2] <- factor(ntng.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntng.results$transcript_id <- rownames(ntng.results)
# Make dataset that has the absent transcripts from the ALO data removed
full.transcript.set <- as.data.frame(rbind(known.results, ntkg.results, ntng.results))
'%!in%' <- function(x,y)!('%in%'(x,y))
transcript.set.hires <- full.transcript.set[which(full.transcript.set$RS.atleast1 %!in% c("Not present")), ]
transcript.set.hires$transcript_id <- rownames(transcript.set.hires)
subtype <- c("Present in both", "Present in ALO IB", "Present in ALO RI")
subtype2 <- c("Present in all strains", "Present in all IB", "Present all RI")
dataList <- list(known.results, ntkg.results, ntng.results)
refDat <- transcript.set.hires
i = 1
i2 = 2
contentQC <- function(subtype, dataList, refDat, i) {
st1 <- subtype[1]
st2 <- subtype[2]
st3 <- subtype[3]
qclist <- do.call("rbind", llply(dataList, .fun = function(x) {
known.pib <- x[which(x[,i] %in% c(st1)), ]
pib.test <- sum(known.pib[,3] %in% refDat$transcript_id) == length(known.pib[,3])
pib.len <- length(known.pib[,3])
known.IB <- x[which(x[,i] %in% c(st2)), ]
IB.test <- sum(known.IB[,3] %in% refDat$transcript_id) == length(known.IB[,3])
IB.len <- length(known.IB[,3])
known.RI <- x[which(x[,i] %in% c(st3)), ]
RI.test <- sum(known.RI[,3] %in% refDat$transcript_id) == length(known.RI[,3])
RI.len <- length(known.RI[,3])
known.test <- sum(pib.test, IB.test, RI.test) == 3
df <- c(pib.len, IB.len, RI.len, sum(pib.len, IB.len, RI.len), known.test)
}))
tots <- apply(qclist, 2, function(x) sum(x))
df.out <- rbind(qclist, tots)
df.out[,5] <- ifelse(df.out[,5] == c(1), "Yes", NA)
rownames(df.out) <- c("Known transcript of known gene", "Novel transcript of known gene", "Novel transcript of novel gene", "Totals")
colnames(df.out) <- c("Present in both", "Present in classic inbreds", "Present in recombinant inbreds", "Totals", "Subset of full dataset")
#names(qclist) <- c("KTKG", "NTKG", "NTNG")
return(df.out)
}
contentQC(subtype, dataList, refDat, i)
contentQC(subtype2, dataList, refDat, i2)
## summarize transcript content using sep.panel function. This function will create useful datasets as well.
content.summary <- sep.panel(PA.table.RMO)
# Subset columns with present/absent codes
known.results <- content.summary$KN_Results[, c(5,6)]
ntkg.results <- content.summary$NTKG_Results[, c(5,6)]
ntng.results <- content.summary$NTNG_Results[, c(5,6)]
# Change codes to factor and give meaningful labels for both known and novel datasets
known.results[, 1] <- factor(known.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
known.results[, 2] <- factor(known.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
known.results$transcript_id <- rownames(known.results)
ntkg.results[, 1] <- factor(ntkg.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntkg.results[, 2] <- factor(ntkg.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntkg.results$transcript_id <- rownames(ntkg.results)
ntng.results[, 1] <- factor(ntng.results[, 1], levels = c(2,6,11,15), labels = c("Present in both", "Present in ALO IB", "Present in ALO RI", "Not present"), ordered = FALSE)
ntng.results[, 2] <- factor(ntng.results[, 2], levels = c(2,6,11,15), labels = c("Present in all strains", "Present in all IB", "Present all RI", "Other"), ordered = FALSE)
ntng.results$transcript_id <- rownames(ntng.results)
# Make dataset that has the absent transcripts from the ALO data removed
full.transcript.set <- as.data.frame(rbind(known.results, ntkg.results, ntng.results))
'%!in%' <- function(x,y)!('%in%'(x,y))
transcript.set.hires <- full.transcript.set[which(full.transcript.set$RS.atleast1 %!in% c("Not present")), ]
transcript.set.hires$transcript_id <- rownames(transcript.set.hires)
subtype <- c("Present in both", "Present in ALO IB", "Present in ALO RI")
subtype2 <- c("Present in all strains", "Present in all IB", "Present all RI")
dataList <- list(known.results, ntkg.results, ntng.results)
refDat <- transcript.set.hires
i = 1
i2 = 2
contentQC <- function(subtype, dataList, refDat, i) {
st1 <- subtype[1]
st2 <- subtype[2]
st3 <- subtype[3]
qclist <- do.call("rbind", llply(dataList, .fun = function(x) {
known.pib <- x[which(x[,i] %in% c(st1)), ]
pib.test <- sum(known.pib[,3] %in% refDat$transcript_id) == length(known.pib[,3])
pib.len <- length(known.pib[,3])
known.IB <- x[which(x[,i] %in% c(st2)), ]
IB.test <- sum(known.IB[,3] %in% refDat$transcript_id) == length(known.IB[,3])
IB.len <- length(known.IB[,3])
known.RI <- x[which(x[,i] %in% c(st3)), ]
RI.test <- sum(known.RI[,3] %in% refDat$transcript_id) == length(known.RI[,3])
RI.len <- length(known.RI[,3])
known.test <- sum(pib.test, IB.test, RI.test) == 3
df <- c(pib.len, IB.len, RI.len, sum(pib.len, IB.len, RI.len), known.test)
}))
tots <- apply(qclist, 2, function(x) sum(x))
df.out <- rbind(qclist, tots)
df.out[,5] <- ifelse(df.out[,5] == c(1), "Yes", NA)
rownames(df.out) <- c("Known transcript of known gene", "Novel transcript of known gene", "Novel transcript of novel gene", "Totals")
colnames(df.out) <- c("Present in both", "Present in classic inbreds", "Present in recombinant inbreds", "Totals", "Subset of full dataset")
#names(qclist) <- c("KTKG", "NTKG", "NTNG")
return(df.out)
}
contentQC(subtype, dataList, refDat, i)
contentQC(subtype2, dataList, refDat, i2)
avgsem
avgsem.forPlot
library("devtools")
library(roxygen2)
setwd("/Users/smiharry/Desktop/Saba_Lab/RLBTCP")
create("rlbtcp")
setwd("./rlbtcp")
document()
setwd("..")
install("rlbtcp")
library(rlbtcp)
?rsem.read.iso
uninstall("rlbtcp")
install("rlbtcp")
library(rlbtcp)
?rsem.read.iso
?rsem.read.gene
uninstall("rlbtcp")
library(rlbtcp)
